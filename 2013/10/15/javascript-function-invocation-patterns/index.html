<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>JavaScript - 函数调用模式 | ALEVEN.SH</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="tags: JavaScript this 翻译JavaScript被描述为一个面向函数语言（有别于面向对象的语言）。因为函数在JavaScript中不仅仅是独立的逻辑执行单元，函数是一等公民，它也提供作用域，且能创建对象。如此依赖函数有好有坏：好的是它使的语言轻且快速（也是该语言发展的初衷），坏的是如果你不知道你在做什么，你很容易把自己绕进去。 JavaScript函数一个需要关心的问题是，不同">
<meta name="keywords" content="假使要我跟你再耗个十年">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript - 函数调用模式">
<meta property="og:url" content="http://yoursite.com/2013/10/15/javascript-function-invocation-patterns/index.html">
<meta property="og:site_name" content="ALEVEN.SH">
<meta property="og:description" content="tags: JavaScript this 翻译JavaScript被描述为一个面向函数语言（有别于面向对象的语言）。因为函数在JavaScript中不仅仅是独立的逻辑执行单元，函数是一等公民，它也提供作用域，且能创建对象。如此依赖函数有好有坏：好的是它使的语言轻且快速（也是该语言发展的初衷），坏的是如果你不知道你在做什么，你很容易把自己绕进去。 JavaScript函数一个需要关心的问题是，不同">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-07-13T06:49:11.595Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript - 函数调用模式">
<meta name="twitter:description" content="tags: JavaScript this 翻译JavaScript被描述为一个面向函数语言（有别于面向对象的语言）。因为函数在JavaScript中不仅仅是独立的逻辑执行单元，函数是一等公民，它也提供作用域，且能创建对象。如此依赖函数有好有坏：好的是它使的语言轻且快速（也是该语言发展的初衷），坏的是如果你不知道你在做什么，你很容易把自己绕进去。 JavaScript函数一个需要关心的问题是，不同">
  
    <link rel="alternate" href="/atom.xml" title="ALEVEN.SH" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/avatar.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-61220413-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">ALEVEN.SH</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog/" id="subtitle">一个酱油前端的心路历程</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/archives">归档</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="description" content="酱油前端许乐乐的博客 bluesh Aleven a Web Developer in Hangzhou Front-end 不有趣"><meta name="keyword"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>JavaScript - 函数调用模式</title><link rel="shortcut icon" href="/images/avatar.png" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"></head><body><header class="container" id="header"><div class="header"><div class="header-left"><div class="avatar"><img src="/images/avatar.png"></div><div class="author"><div class="author-name"><a href="/">GARY.SHEN</a></div><div class="about-me">Halo~</div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">归档</a></li></ul></div><div class="about-me-mask"><div class="about-me-wrap"><div class="about-me__header"><div class="avatar"><img src="/images/avatar.png"></div></div><ul class="socials"><li class="social-item"><span class="label"><img src="/images/socials/github.svg" alt="https://github.com/gary-Shen"></span><a href="https://github.com/gary-Shen" target="_blank" title="https://github.com/gary-Shen">https://github.com/gary-Shen</a></li><li class="social-item"><span class="label"><img src="/images/socials/email.svg" alt="guanlinshen@126.com"></span><span>guanlinshen@126.com</span></li><li class="social-item"><span class="label"><img src="/images/socials/wechat.svg" alt="Grinson"></span><span>Grinson</span></li></ul></div></div></div></header><div class="container post"><section class="article"><div class="title">JavaScript - 函数调用模式</div><div class="date">写于2013年10月15日</div><div class="content"><p>tags: <code>JavaScript</code> <code>this</code> <code>翻译</code><br><br><br>JavaScript被描述为一个面向函数语言（有别于面向对象的语言）。因为函数在JavaScript中不仅仅是独立的逻辑执行单元，函数是一等公民，它也提供作用域，且能创建对象。如此依赖函数有好有坏：好的是它使的语言轻且快速（也是该语言发展的初衷），坏的是如果你不知道你在做什么，你很容易把自己绕进去。</p>
<p>JavaScript函数一个需要关心的问题是，不同的调用模式可以产生截然不同的结果。这篇文章介绍了四种模式，如何使用它们，要注意些什么。四种调用模式如下：</p>
<p>1、方法调用（Method Invocation）</p>
<p>2、函数调用（Function Invocation）</p>
<p>3、构造函数调用（Constructor Invocation）</p>
<p>4、apply和call调用（Apply And Call Invocation）</p>
<p>##函数执行</p>
<p>Javascript（像现今所有语言）函数有逻辑模块化的功能，它可以在执行的任何时候被调用。调用函数时，暂停执行当前函数，传递控制和参数给被调用的函数。此外，this参数也被传递给函数。调用操作符是一对圆括号（） ，它可以包含0个或多个以逗号分隔的表达式。</p>
<p>不幸的是，有多种模式可用来调用函数。这些模式并不是nice-to-know：绝对有必要了解它们。因为不同模式调用函数可以产生截然不同的结果。我认为这是JavaScript在语言设计上的错误，如果设计语言时多些思考（少些匆忙），也不会产生这么大的问题。</p>
<p>##四种调用模式</p>
<p>虽然只有一个调用操作符（），但有四种调用模式。每种模式在初始化this参数时有所不同。</p>
<p>###方法调用</p>
<p>对象中的函数，称为方法。方法调用是调用对象中的函数的模式。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.increment(); <span class="comment">//Method invocation</span></span><br></pre></td></tr></table></figure></p>
<p>若函数前面有对象实例object，则称为方法调用。JavaScript将this参数指向调用方法的对象。如上例，this指向obj。Javascript在执行时绑定this（也被称为晚绑定）。</p>
<p>###函数调用</p>
<p>使用（）调用函数，称为函数调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<p>使用函数调用模式，this指向全局对象。这是JavaScript语言中的错误！盲目绑定this到全局对象会破坏当前上下文。尤其是在方法函数内使用<code>内部函数</code>。下面这个例子做了很好地解释：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">500</span>; <span class="comment">//Global variable</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> innerFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        innerFunction(); <span class="comment">//Function invocation pattern</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.increment(); <span class="comment">//Method invocation pattern</span></span><br></pre></td></tr></table></figure>
<p>你认为屏幕上显示什么？答案是1的，不好意思你错了（但不要太为难自己，这是JavaScript没有处理好）。真正的答案是500。注意，innerFunction使用函数调用模式，因此this被设置为全局对象。结果就是innerFunction（再次强调，它是函数调用模式）没有指向当前对象的this参数。相反，它（this）被设置到全局对象，其value值被定义为500。我要强调，这是很糟糕的语言设计；增量函数采用方法调用模式来调用，很自然地认为在内部使用它时，this应该总是指向当前函数。</p>
<p>有一个简单的方法来避开这个问题，但在我看来是一种hack。在函数内部定义一个变量（按照惯例，命名为that），将this赋值给这个变量。（题外话：这种方式可行使因为JavaScript中的函数是闭包）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">500</span>; <span class="comment">//Global variable</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        that.value++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> innerFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(that.value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        innerFunction(); <span class="comment">//Function invocation pattern</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.increment();</span><br></pre></td></tr></table></figure>
<p>如果this可以绑定到调用的当前对象作用域，函数和方法调用是一样的。</p>
<p>###构造函数调用</p>
<p>注意：这是JavaScript另一个特点！JavaScript不是class式面向对象的语言。相反，它是一个propertype式面向对象的语言，但JavaScript的创建者认为，熟悉传统的面向对象经验的人（绝大多数）可能对纯粹的原型形式不满。这导致JavaScript对其原型特征不确定，最糟糕的事情发生了：它混合了经典的面向对象的语法和自身原型性质。结果：一塌糊涂！</p>
<p>传统的面向对象，对象是类的实例。在C++和Java中，这个实例是通过使用new操作符生成。这似乎是构造函数调用模式背后的灵感…</p>
<p>构造函数调用模式是，在被调用的函数之前用new操作符。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Cheese = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cheeseType = type;</span><br><span class="line">    <span class="keyword">return</span> cheeseType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cheddar = <span class="keyword">new</span> Cheese(<span class="string">"cheddar"</span>); <span class="comment">//new object returned, not the type.</span></span><br></pre></td></tr></table></figure>
<p>虽然Cheese是一个函数对象（有人将函数作为运行模块化的代码块），通过调用带new关键字的函数，来创建一个新的对象。this参数将指向新创建的对象，而函数的return操作符，will have its behaviour altered。关于构造函数调用的return操作符行为有两种情况：</p>
<p>1、如果该函数返回一个简单类型（number, string, boolean, null or undefined），忽略return，返回this（指向新的对象）。<br>2、如果该函数返回一个object实例（简单类型以外的任何类型），那么将返回的对象，而不是返回this。这种模式是不经常使用，但当它与闭包相结合的时候非常有用。</p>
<p>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    data : <span class="string">"Hello World"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Func1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Func2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"I am a simple type"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Func1(); <span class="comment">//f1 is set to obj</span></span><br><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">new</span> Func2(); <span class="comment">//f2 is set to a new object</span></span><br></pre></td></tr></table></figure></p>
<p>我们可能会忽略JavaScript创建者给予该语言的独特之处：利用任意原型链创建对象，而只使用对象字面量来创建对象。这种模式很直观但也存在潜在问题。不过可以通过扩展对象的创建方法，实现构造函数调用模式的方法，<a href="http://doctrina.org/JavaScript:Why-Understanding-Scope-And-Closures-Matter.html#closureandconstructor" target="_blank" rel="noopener">例子</a>。JavaScript 1.8.5实现了Object.create。构造函数调用仍然频繁使用。</p>
<p>###apply和call调用</p>
<p>apply模式相比之前的模式，没有那么糟糕。apply方法允许，通过传递参数数组给函数来手动调用函数，明确设置this参数。因为函数是一等公民，他们也是对象，因此也可以运行方法（函数）。事实上，每一个function都指向Function.prototype,因此方法可以很容易扩展函数。apply方法就是一个函数扩展方法-我的猜想-它定义在Function.prototype中。</p>
<p>apply有两个参数：第一个参数是this参数绑定的对象，第二个参数是一个数组，它被映射为第一个对象的参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array = [<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">add.apply(<span class="literal">null</span>,array); <span class="comment">//7</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，this为空（该函数不是一个对象，所以它不需要）和数组为num1与num2。第一个参数可以更有趣：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    data:<span class="string">'Hello World'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> displayData = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">displayData(); <span class="comment">//undefined</span></span><br><span class="line">displayData.apply(obj); <span class="comment">//Hello World</span></span><br></pre></td></tr></table></figure>
<p>上面的例子使用apply绑定this到obj。结果产生一个this.data值。apply的实际应用价值,就是能明确分配一个值给this.。要是没有这个功能，我们可以直接使用（）来调用函数。</p>
<p>JavaScript还有种调用方法是call，类似apply方法,不过它传递的不是一个参数数组,而是一个参数列表。如果JavaScript可以实现的函数重载，我认为call应该是apply方法的重载。因此，人们谈论的apply和call其实是一样的。</p>
<p>##结论</p>
<p>无论好坏，JavaScript都已经流行了。了解语言的特征,并避免这种特性带来的异常非常重要。学习四种函数调用方法哪里不同，以及如何避免缺陷是使用JavaScript的基础。</p>
<p>原文：<a href="http://doctrina.org/Javascript-Function-Invocation-Patterns.html" target="_blank" rel="noopener">http://doctrina.org/Javascript-Function-Invocation-Patterns.html</a></p>
<p>##废话在后<br>总结下this.</p>
<ol>
<li><p>对于obj.fun()此类方法函数调用,哪个<code>对象实例</code>(obj)调用this所在的函数(fun),this指向那个<code>对象实例</code></p>
</li>
<li><p>对于函数调用,this指向全局对象.(其实可以看做上一种,是window对象的方法函数,全局对象调用,则指向全局对象).避免这种语言设计不合理的一个小技巧就是,进入函数后就申明一个变量_this,赋值this给它(_this),保存下来.</p>
</li>
<li><p>对于构造函数调用,若该函数返回一个简单类型（number, string, boolean, null or undefined），忽略return值，返回this（指向新的对象）;如果该函数返回一个object实例（简单类型以外的任何类型），那么将返回该对象。</p>
</li>
<li><p>apply和call调用,this指向apply和call第一参数.即手动设置this的值.</p>
</li>
</ol>
<p>10 months ago 完.</p>
</div><div class="tags"><a class="tag-link" href="/blog/tags/假使要我跟你再耗个十年/">假使要我跟你再耗个十年</a></div></section></div><div class="container"><ul class="nav"><li>上一篇：<a href="/blog/2013/10/15/handbook/">爱整理的都是好姑凉</a></li><li>下一篇：<a href="/blog/2013/10/12/no-longer/">好像没有然后了</a></li></ul></div><div id="backToTop"><div class="back-arrow back-arrow-left"></div><div class="back-arrow back-arrow-right"></div></div><footer class="container"><div class="rights"><span>Powered by </span><a href="http://hexo.io" target="_blank">Hexo</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-curry" target="_blank">Curry</a><span>.</span></div></footer><script src="/blog/script/jquery.min.js"></script><link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css"><script src="/blog/fancybox/jquery.fancybox.pack.js"></script><script src="/blog/script/index.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-61220413-1', 'auto');
ga('send', 'pageview');</script><script src="/blog/script/jquery.min.js"></script><link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css"><script src="/blog/fancybox/jquery.fancybox.pack.js"></script><script src="/blog/script/index.js"></script><script src="/blog/script/post.js"></script></body></html></section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 ALEVEN.SH<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/archives" class="mobile-nav-link">归档</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>

  </div>
</body>
</html>